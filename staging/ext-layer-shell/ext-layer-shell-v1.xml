<?xml version="1.0" encoding="UTF-8"?>
<protocol name="ext_layer_shell_v1">
  <copyright>
    Copyright © 2017 Drew DeVault
    Copyright © 2022 Simon Ser

    Permission to use, copy, modify, distribute, and sell this
    software and its documentation for any purpose is hereby granted
    without fee, provided that the above copyright notice appear in
    all copies and that both that copyright notice and this permission
    notice appear in supporting documentation, and that the name of
    the copyright holders not be used in advertising or publicity
    pertaining to distribution of the software without specific,
    written prior permission.  The copyright holders make no
    representations about the suitability of this software for any
    purpose.  It is provided "as is" without express or implied
    warranty.

    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
    THIS SOFTWARE.
  </copyright>

  <description summary="create surfaces that are layers of the desktop">
    Clients can use this protocol extension to assign the layer surface role to
    wl_surfaces. Such surfaces are assigned to a "layer" of the output and
    rendered with a defined z-depth respective to each other. They may also be
    anchored to the edges and corners of a screen and specify input handling
    semantics. This interface should be suitable for the implementation of
    many desktop shell components, and a broad number of other applications
    that interact with the desktop.

    The compositor may choose to restrict this protocol to a special client
    launched by the compositor itself or expose it to all privileged clients,
    this is compositor policy.

    The key words "must", "must not", "required", "shall", "shall not",
    "should", "should not", "recommended",  "may", and "optional" in this
    document are to be interpreted as described in IETF RFC 2119.

    Warning! The protocol described in this file is currently in the
    testing phase. Backward compatible changes may be added together with
    the corresponding interface version bump. Backward incompatible changes
    can only be done by creating a new major version of the extension.
  </description>

  <interface name="ext_layer_shell_v1" version="1">
    <description summary="create surfaces that are layers of the desktop">
      This interface is exposed as a global enabling clients to turn their
      wl_surfaces into layer surfaces.
    </description>

    <enum name="error">
      <entry name="role" value="1" summary="wl_surface has another role"/>
    </enum>

    <request name="destroy" type="destructor">
      <description summary="destroy the layer_shell object">
        This request indicates that the client will not use the layer_shell
        object any more. Objects that have been created through this instance
        are not affected.
      </description>
    </request>

    <request name="get_layer_surface">
      <description summary="create a layer surface">
        Create a layer surface for an existing wl_surface. This assigns the
        role of layer_surface, or raises a protocol error if another role is
        already assigned.

        Creating a layer surface from a wl_surface which has a buffer attached
        or committed is a client error, and any attempts by a client to attach
        or manipulate a buffer prior to the first layer_surface.configure call
        must also be treated as errors.

        After creating a layer_surface object, the client must send a set_layer
        request to define the surface's layer. The client can send other
        requests to setup the layer surface, and then must perform an initial
        commit without any buffer attached. The compositor will reply with a
        layer_surface.configure event. The client must acknowledge it and is
        then allowed to attach a buffer to map the surface.

        You may pass NULL for output to allow the compositor to decide which
        output to use.
      </description>
      <arg name="id" type="new_id" interface="ext_layer_surface_v1"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
    </request>
  </interface>

  <interface name="ext_layer_surface_v1" version="1">
    <description summary="layer surface">
      An interface that may be implemented by a wl_surface, for surfaces that
      are designed to be rendered as a layer of a stacked desktop-like
      environment.

      Layer surface state (layer, size, anchor, exclusive zone,
      margin, interactivity) is double-buffered, and will be applied at the
      time wl_surface.commit of the corresponding wl_surface is called.

      Attaching a null buffer to a layer surface unmaps it.

      Unmapping a layer_surface means that the surface cannot be shown by the
      compositor until it is explicitly mapped again. The layer_surface
      returns to the state it had right after layer_shell.get_layer_surface.
      The client can re-map the surface by performing a commit without any
      buffer attached, waiting for a configure event and handling it as usual.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the layer surface">
        This request destroys the layer surface.
      </description>
    </request>

    <enum name="error">
      <entry name="already_constructed" value="1" summary="a layer surface has already been constructed for this wl_surface"/>
      <entry name="unconfigured_buffer" value="2" summary="wl_surface has a buffer attached or committed"/>
      <entry name="invalid_layer" value="3" summary="layer is invalid"/>
      <entry name="invalid_size" value="4" summary="size is invalid"/>
      <entry name="invalid_anchor" value="5" summary="anchor is invalid"/>
      <entry name="invalid_exclusive_zone" value="6" summary="exclusive zone is invalid"/>
      <entry name="invalid_margin" value="7" summary="margin is invalid"/>
      <entry name="invalid_keyboard_interactivity" value="8" summary="keyboard interactivity is invalid"/>
      <entry name="invalid_serial" value="9" summary="ack_configure sent with an invalid serial"/>
      <entry name="no_layer" value="10" summary="set_layer not sent before first commit"/>
    </enum>

    <enum name="layer">
      <description summary="available layers for surfaces">
        These values indicate which layers a surface can be rendered in. They
        are ordered by z depth, bottom-most first. Traditional shell surfaces
        will typically be rendered between the bottom and top layers.
        Fullscreen shell surfaces are typically rendered between the top and
        overlay layers. Multiple surfaces can share a single layer, and
        ordering within a single layer is undefined.
      </description>

      <entry name="background" value="0"/>
      <entry name="bottom" value="1"/>
      <entry name="top" value="2"/>
      <entry name="overlay" value="3"/>
    </enum>

    <request name="set_layer">
      <description summary="set the layer of the surface">
        Set the layer of the surface.

        Layer is double-buffered, see wl_surface.commit.
      </description>
      <arg name="layer" type="uint" enum="layer"/>
    </request>

    <request name="set_size">
      <description summary="request a size for the surface">
        Request that the compositor reserves the provided size for the layer
        surface. The lengths are provided in surface-local coordinates. The
        compositor will display the surface centered with respect to its
        anchors.

        If either value is 0, the compositor will pick a value (e.g. to use all
        available space) and send it back (see the configure event). In that
        case, the surface must not be anchored on that axis, or else the
        invalid_size protocol error is raised.

        The compositor is free to send a size in the configure event which
        doesn't match the size provided by the client in set_size.

        Size is double-buffered, see wl_surface.commit.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <enum name="anchor" bitfield="true">
      <entry name="top" value="1" summary="the top edge of the anchor rectangle"/>
      <entry name="bottom" value="2" summary="the bottom edge of the anchor rectangle"/>
      <entry name="left" value="4" summary="the left edge of the anchor rectangle"/>
      <entry name="right" value="8" summary="the right edge of the anchor rectangle"/>
    </enum>

    <request name="set_anchor">
      <description summary="set the anchor point of the surface">
        Request that the compositor anchors the surface to the specified edge
        or corner. If two orthogonal edges are specified (e.g. 'top' and
        'left'), then the anchor point will be the intersection of the edges
        (e.g. the top left corner of the output); otherwise the anchor point
        will be centered on that edge, or in the center if none is specified.

        Providing two opposite edges is an invalid_anchor protocol error.

        Anchor is double-buffered, see wl_surface.commit.
      </description>
      <arg name="anchor" type="uint" enum="anchor"/>
    </request>

    <request name="set_exclusive_zone">
      <description summary="set the exclusive geometry of this surface">
        Request that the compositor avoids occluding an area with other
        surfaces. The compositor's use of this information is
        implementation-dependent - do not assume that this region will not
        actually be occluded.

        A positive value is only meaningful if the surface is anchored to a
        single edge. Otherwise, the invalid_exclusive_zone protocol error is
        raised.

        A positive zone is the distance from the edge in surface-local
        coordinates to consider exclusive.

        Surfaces that do not wish to have an exclusive zone may instead specify
        how they should interact with surfaces that do. If set to zero, the
        surface indicates that it would like to be moved to avoid occluding
        surfaces with a positive exclusive zone. If set to -1, the surface
        indicates that it would not like to be moved to accommodate for other
        surfaces, and the compositor should extend it all the way to the edges
        it is anchored to.

        For example, a panel might set its exclusive zone to 10, so that
        maximized shell surfaces are not shown on top of it. A notification
        might set its exclusive zone to 0, so that it is moved to avoid
        occluding the panel, but shell surfaces are shown underneath it. A
        wallpaper or lock screen might set their exclusive zone to -1, so that
        they stretch below or over the panel.

        The default value is 0.

        Exclusive zone is double-buffered, see wl_surface.commit.
      </description>
      <arg name="zone" type="int"/>
    </request>

    <request name="set_margin">
      <description summary="set the margin of this surface">
        Request that the surface be placed some distance away from the edges
        on the output, in surface-local coordinates.

        Setting one of the margin values to a negative number is an
        invalid_margin protocol error.

        The exclusive zone includes the margin. When the compositor centers the
        surface on an axis (because the surface is not anchored on that axis),
        the margin is counted as part of the surface bounds.

        Margin is double-buffered, see wl_surface.commit.
      </description>
      <arg name="top" type="int"/>
      <arg name="right" type="int"/>
      <arg name="bottom" type="int"/>
      <arg name="left" type="int"/>
    </request>

    <enum name="keyboard_interactivity">
      <description summary="keyboard interaction types">
        Types of keyboard interaction possible for layer shell surfaces.
      </description>
      <entry name="none" value="0">
        <description summary="no keyboard focus is possible">
          This value indicates that this surface is not interested in keyboard
          events and the compositor should never assign it the keyboard focus.

          This is the default value, set for newly created layer shell surfaces.

          This is useful for e.g. desktop widgets that display information or
          only have interaction with non-keyboard input devices.
        </description>
      </entry>
      <entry name="on_demand" value="1">
        <description summary="request regular keyboard focus semantics">
          This requests the compositor to allow this surface to be focused and
          unfocused by the user in an implementation-defined manner. The user
          should be able to unfocus this surface even regardless of the layer
          it is on.

          Typically, the compositor will want to use its normal mechanism to
          manage keyboard focus between layer shell surfaces with this setting
          and regular toplevels on the desktop layer (e.g. click to focus).
          Nevertheless, it is possible for a compositor to require a special
          interaction to focus or unfocus layer shell surfaces (e.g. requiring
          a click even if focus follows the mouse normally, or providing a
          keybinding to switch focus between layers).

          This setting is mainly intended for desktop shell components (e.g.
          panels) that allow keyboard interaction. Using this option can allow
          implementing a desktop shell that can be fully usable without the
          mouse.
        </description>
      </entry>
    </enum>

    <request name="set_keyboard_interactivity">
      <description summary="request keyboard events">
        Set how keyboard events are delivered to this surface. By default,
        layer shell surfaces do not receive keyboard events; this request can
        be used to change this.

        This setting is inherited by child surfaces set by the get_popup
        request.

        Layer surfaces receive pointer, touch, and tablet events normally. If
        you do not want to receive them, set the input region on your surface
        to an empty region.

        Keyboard interactivity is double-buffered, see wl_surface.commit.
      </description>
      <arg name="keyboard_interactivity" type="uint" enum="keyboard_interactivity"/>
    </request>

    <request name="set_app_id">
      <description summary="set application ID">
        Set an application identifier for the surface.

        The app ID identifies the general class of applications to which
        the surface belongs. The compositor can use this to organize surfaces
        of a given application differently, or fetch more metadata about the
        application.

        As a best practice, it is suggested to select app ID's that match the
        basename of the application's .desktop file. For example,
        "org.freedesktop.FooViewer" where the .desktop file is
        "org.freedesktop.FooViewer.desktop".

        See the desktop-entry specification [0] for more details on
        application identifiers and how they relate to .desktop files.

        [0]: http://standards.freedesktop.org/desktop-entry-spec/
      </description>
      <arg name="app_id" type="string"/>
    </request>

    <request name="attach_popup">
      <description summary="assign this layer_surface as an xdg_popup parent">
        This assigns an xdg_popup's parent to this layer_surface. This popup
        should have been created via xdg_surface.get_popup with the parent set
        to NULL, and this request must be invoked before committing the popup's
        initial state.

        See the documentation of xdg_popup for more details about what an
        xdg_popup is and how it is used.
      </description>
      <arg name="popup" type="object" interface="xdg_popup"/>
    </request>

    <request name="ack_configure">
      <description summary="ack a configure event">
        When a configure event is received, if a client commits the
        surface in response to the configure event, then the client
        must make an ack_configure request sometime before the commit
        request, passing along the serial of the configure event.

        If the client receives multiple configure events before it
        can respond to one, it only has to ack the last configure event.

        A client is not required to commit immediately after sending
        an ack_configure request - it may even ack_configure several times
        before its next surface commit.

        A client may send multiple ack_configure requests before committing, but
        only the last request sent before a commit indicates which configure
        event the client really is responding to.

        Sending an ack_configure request consumes the serial number sent with
        the request, as well as serial numbers sent by all configure events
        sent on this xdg_surface prior to the configure event referenced by
        the committed serial.

        It is an error to issue multiple ack_configure requests referencing a
        serial from the same configure event, or to issue an ack_configure
        request referencing a serial from a configure event issued before the
        event identified by the last ack_configure request for the same
        layer surface. Doing so will raise an invalid_serial protocol error.
      </description>
      <arg name="serial" type="uint" summary="the serial from the configure event"/>
    </request>

    <event name="configure">
      <description summary="suggest a surface change">
        The configure event asks the client to resize its surface.

        Clients should arrange their surface for the new states, and then send
        an ack_configure request with the serial sent in this configure event at
        some point before committing the new surface.

        The client is free to dismiss all but the last configure event it
        received.

        The width and height arguments specify the size of the window in
        surface-local coordinates.

        The size is a hint, in the sense that the client is free to ignore it if
        it doesn't resize, pick a smaller size (to satisfy aspect ratio or
        resize in steps of NxM pixels). If the client picks a smaller size and
        is not anchored on an axis, the surface will be centered on this axis.

        If the width or height arguments are zero, it means the client should
        decide its own window dimension.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </event>

    <event name="closed">
      <description summary="surface should be closed">
        The closed event is sent by the compositor when the surface will no
        longer be shown. The output may have been destroyed or the user may
        have asked for it to be removed. Further changes to the surface will be
        ignored. The client should destroy the resource after receiving this
        event, and create a new surface if they so choose.
      </description>
    </event>
  </interface>
</protocol>
