<?xml version="1.0" encoding="UTF-8"?>
<protocol name="refresh_cycle_v1">
  <copyright>
    Copyright Â© 2023 Red Hat, Inc.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice (including the next
    paragraph) shall be included in all copies or substantial portions of the
    Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
  </copyright>

  <description summary="Protocol for requesting refresh cycle information">
    <!-- TODO -->
  </description>

  <interface name="wp_refresh_cycle_manager_v1" version="1">
    <description summary="refresh cycle factory">
      This global is a wp_refresh_cycle_v1 factory.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the manager">
        Destroy the manager object.

        Existing objects created through this interface remain valid.
      </description>
    </request>

    <request name="create">
      <description summary="create a refresh cycle object for a surface">
        Create a wp_refresh_cycle_v1 object tied to a wl_surface.
      </description>
      <arg name="refresh_cycle" type="new_id" interface="wp_refresh_cycle_v1"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <event name="clock_id">
      <description summary="clock ID for timestamps">
        This event tells the client in which clock domain the compositor
        interprets the timestamps used by the refresh cycle extension. This
        clock is called the refresh cycle clock.

        The compositor sends this event when the client binds to the
        wp_refresh_cycle_manager interface. The refresh cycle clock does not
        change during the lifetime of the client connection.

        The clock identifier is platform dependent. On Linux/glibc, the
        identifier value is one of the clockid_t values accepted by
        clock_gettime(). clock_gettime() is defined by POSIX.1-2001.

        Timestamps in this clock domain are expressed as tv_sec_hi, tv_sec_lo,
        tv_nsec triples, each component being an unsigned 32-bit value. Whole
        seconds are in tv_sec which is a 64-bit value combined from tv_sec_hi
        and tv_sec_lo, and the additional fractional part in tv_nsec as
        nanoseconds. Hence, for valid timestamps tv_nsec must be in
        [0, 999999999].

        Note that clock_id applies only to the refresh cycle clock, and implies
        nothing about e.g. the timestamps used in the Wayland core protocol
        input events.

        Compositors should prefer a clock which does not jump and is not slewed
        e.g. by NTP. The absolute value of the clock is irrelevant. Precision of
        one millisecond or better is recommended. Clients must be able to query
        the current clock value directly, not by asking the compositor.
      </description>
      <arg name="clk_id" type="uint" summary="platform clock identifier"/>
    </event>
  </interface>

  <interface name="wp_refresh_cycle_v1" version="1">
    <description summary="">
      <!-- TODO -->
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the refresh cycle object">
        Destroy the refresh cycle object.
      </description>
    </request>

    <enum name="refresh_state">
      <description summary="">
        Describes when and how to expect latching events.
      </description>
      <entry name="none" value="0">
        <description summary="no refresh cycle">
          Indicates that the output does not have a concept of vertical retrace
          or a refresh cycle, or that the output device is self-refreshing
          without a way to query the refresh count.

          No latching events are sent in this state.
        </description>
      </entry>
      <entry name="active" value="1">
        <description summary="active refresh cycle">
          Indicates that latching events are sent.
        </description>
      </entry>
      <entry name="degraded" value="2">
        <description summary="degraded refresh cycle">
          Indicates that latching events are sent but might be unreliable or
          erratic.
        </description>
      </entry>
      <entry name="suspended" value="3">
        <description summary="refresh cycles are suspended">
          Indicates that the surface is hidden or otherwise obstructed.

          No latching events are sent in this state.
        </description>
      </entry>
    </enum>

    <enum name="latching_kind">
      <description summary="">
        Describes how to interpret latching events.
      </description>
      <entry name="regular" value="0">
        <description summary="">
          The latching events occur in relatively regular intervals. If the
          frequency or phase changes suddenly an invalidate event will be sent.
          The next predicted latching event will not deviate from the actual
          next latching event by a lot.
        </description>
      </entry>
      <entry name="erratic" value="1">
        <description summary="">
          The latching events occur in erratic intervals. The next predicted
          latching event is set to zero. It is not advisable to try and predict
          the next latching event.
        </description>
      </entry>
    </enum>

    <event name="state">
      <description summary="the refresh cycle state">
        The refresh cycle state.
      </description>
      <arg name="refresh_state" type="uint" enum="refresh_state"
           summary="the refresh state"/>
      <arg name="latching_kind" type="uint" enum="latching_kind"
           summary="the latching kind"/>
    </event>

    <event name="invalidate">
      <description summary="invalidate previous latching events">
        The latching events sent prior to this event should not be used to
        predict any future events.

        This is typically sent when the surface changes the output or the mode
        of the current output changes, making the previous latching events
        invalid.
      </description>
    </event>

    <event name="latching">
      <description summary="">
        The latching event is sent no earlier than the compositor deciding which
        commits will be chosen for the next presentation, but as close to it as
        possible.

        The exact time of this event is recorded in the commit latching
        timestamp (commit_tv_sec_hi/lo, commit_tv_nsec).

        The buffer latching timestamp (buffer_tv_sec_hi/lo, buffer_tv_nsec)
        describes when all the fences of buffers attached to surfaces of a
        commit must be signaled in order to get presented on the refresh cycle
        of this latching event.

        For the interpretation of the timestamps, see
        wp_refresh_cycle_manager.clock_id event.

        The 64-bit value combined from seq_hi and seq_lo is the value of the
        output's vertical retrace counter of the following presentation. This
        value must be compatible with the seq_hi and seq_lo of the
        presentation-time protocol.
      </description>
      <arg name="commit_tv_sec_hi" type="uint"
           summary="high 32 bits of the seconds part of the commit latching timestamp"/>
      <arg name="commit_tv_sec_lo" type="uint"
           summary="low 32 bits of the seconds part of the commit latching timestamp"/>
      <arg name="commit_tv_nsec" type="uint"
           summary="nanoseconds part of the commit latching timestamp"/>
      <arg name="buffer_tv_sec_hi" type="uint"
           summary="high 32 bits of the seconds part of the buffer latching timestamp"/>
      <arg name="buffer_tv_sec_lo" type="uint"
           summary="low 32 bits of the seconds part of the buffer latching timestamp"/>
      <arg name="buffer_tv_nsec" type="uint"
           summary="nanoseconds part of the buffer latching timestamp"/>
      <arg name="seq_hi" type="uint"
           summary="high 32 bits of refresh counter"/>
      <arg name="seq_lo" type="uint"
           summary="low 32 bits of refresh counter"/>
    </event>

  </interface>
</protocol>
